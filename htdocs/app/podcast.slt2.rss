#{

local function date_rfc_822(time)
	if not time then time = os.time() end
	return os.date('%a, %d %b %Y %H:%M:%S %z', time)
end

local function url_escape(s)
	return string.gsub(s, "([^A-Za-z0-9_%./:-])", function(c)
		-- iTunes bails at +. if c == ' ' then return '+' end
		return string.format("%%%02x", string.byte(c))
	end)
end

local function url(s)
	return url_escape(s)
end

assert(podcast, 'podcast')
assert(podcast.id, 'podcast id')

local base_url = Recorder.base_url()
assert(base_url, 'base_url')

-- sort reverse, newest first:
local bcs = podcast:broadcasts(function(a,b) return a.id > b.id end)

local bc_most_recent = nil
for _,bc in ipairs(bcs) do
	if 'file' == lfs.attributes(table.concat{bc:enclosure().id, '.mp3'}, 'mode') then
		bc_most_recent = bc
		break
	end
end

local rss_url = url(table.concat{base_url, 'podcasts/', podcast.id, '.rss'})

 }<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
	<link>#{= rss_url }</link>
	<atom:link href="#{= rss_url }" rel="self" type="application/rss+xml" />
	<title>Rec2013 #{= podcast.title }</title>
	<itunes:subtitle>#{= podcast.subtitle }</itunes:subtitle>
	<description></description>
	<itunes:summary></itunes:summary>
#{	if bc_most_recent and bc_most_recent:pbmi().DC_image then }	   <!-- image of most recent enclosure -->
	<image>
	  <link>#{= rss_url }</link>
	  <title>Rec2013 #{= podcast.title }</title>
	  <url>#{= bc_most_recent:pbmi().DC_image }</url>
	</image>
	<itunes:image href="#{= bc_most_recent:pbmi().DC_image }"/>
#{ end }	<itunes:explicit>no</itunes:explicit>
	<language>de</language>
	<lastBuildDate>#{= date_rfc_822() }</lastBuildDate>
	<pubDate>#{= date_rfc_822() }</pubDate>
#{
	for _,bc in ipairs(bcs) do
		local start = assert(bc:dtstart())
		local end_ = assert(bc:dtend())
		local bc_url = url(table.concat{base_url, 'stations', '/', bc.id, '.html'})
 }	  <item>
	  <title>#{= bc:pbmi().DC_title:escape_xml() }</title>
	  <itunes:subtitle>#{= bc:pbmi().DC_title_episode:escape_xml() }</itunes:subtitle>
	  <description>#{= bc:pbmi().DC_description:escape_xml() }</description>
	  <itunes:image href="#{= bc:pbmi().DC_image }"/>
	  <pubDate>#{= date_rfc_822(start) }</pubDate>
	  <guid isPermaLink="true">#{= bc_url }</guid>
	  <itunes:duration>#{= os.difftime(end_,start) }</itunes:duration>
	  <itunes:explicit>clean</itunes:explicit>
	  <itunes:author>#{= bc:pbmi().DC_creator:escape_xml() }</itunes:author>
	  <link>#{= bc_url }</link>
#{ if 'mp3' == bc:enclosure().state then
		local file_size = lfs.attributes(table.concat{bc:enclosure().id, '.mp3'}, 'size')
 }		<enclosure type="audio/mpeg" url="#{= url(table.concat{base_url, bc:enclosure().id, '.mp3'}) }" length="#{= file_size }"/>
#{ end }	</item>
#{ end }  </channel>
</rss>
